<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ECMA-262 Clause 4 | Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="4 Overview4.2 ECMA Overview接下来是非正式的ECMAScript的概述-并非所有的语言的部分被描述.这个概述不是标准的一部分. ECMAScript是一种基于对象的语言并且基础类型由对象提供，一个ECMAScript程序由一些通信的对象构成。在EMCAScript中一个对象由n(&amp;gt;=0)个特有属性组成，而每个特有属性被若干固定属性描述如何使用-如当Writeable">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMA-262 Clause 4">
<meta property="og:url" content="https://qudi15.github.io/blog/2017/08/21/ecma-262-4/index.html">
<meta property="og:site_name" content="Blogs">
<meta property="og:description" content="4 Overview4.2 ECMA Overview接下来是非正式的ECMAScript的概述-并非所有的语言的部分被描述.这个概述不是标准的一部分. ECMAScript是一种基于对象的语言并且基础类型由对象提供，一个ECMAScript程序由一些通信的对象构成。在EMCAScript中一个对象由n(&amp;gt;=0)个特有属性组成，而每个特有属性被若干固定属性描述如何使用-如当Writeable">
<meta property="og:image" content="https://qudi15.github.io/images/ecma/prototype-relationships.jpg">
<meta property="og:updated_time" content="2017-08-23T05:08:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ECMA-262 Clause 4">
<meta name="twitter:description" content="4 Overview4.2 ECMA Overview接下来是非正式的ECMAScript的概述-并非所有的语言的部分被描述.这个概述不是标准的一部分. ECMAScript是一种基于对象的语言并且基础类型由对象提供，一个ECMAScript程序由一些通信的对象构成。在EMCAScript中一个对象由n(&amp;gt;=0)个特有属性组成，而每个特有属性被若干固定属性描述如何使用-如当Writeable">
<meta name="twitter:image" content="https://qudi15.github.io/images/ecma/prototype-relationships.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Blogs" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://qudi15.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ecma-262-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017/08/21/ecma-262-4/" class="article-date">
  <time datetime="2017-08-21T08:34:50.000Z" itemprop="datePublished">2017-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ECMA-262 Clause 4
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="4-Overview"><a href="#4-Overview" class="headerlink" title="4 Overview"></a>4 Overview</h1><h2 id="4-2-ECMA-Overview"><a href="#4-2-ECMA-Overview" class="headerlink" title="4.2 ECMA Overview"></a>4.2 ECMA Overview</h2><p>接下来是非正式的ECMAScript的概述-并非所有的语言的部分被描述.这个概述不是标准的一部分.</p>
<p>ECMAScript是一种<strong>基于对象</strong>的语言并且<em>基础类型</em>由对象提供，一个ECMAScript程序由一些通信的对象构成。在EMCAScript中一个对象由n(&gt;=0)个<em>特有属性</em>组成，而每个<em>特有属性</em>被若干<em>固定属性</em>描述如何使用-如当Writeable固定属性被设置成<strong>false</strong>，任何企图修改这个<em>特有属性</em>的值都会失败。特有属性是另外一些对象，<em>简单值</em>或<em>函数</em>的容器(引用)。一个简单值得数据类型可以是:<strong>Undefined</strong>，<strong>Boolean</strong>，<strong>Number</strong>，<strong>String</strong> 或 <strong>Symbol</strong>；一个对象的类型是<strong>Object</strong>；一个函数是一个可以被调用的对象。如果对象的特有属性是一个函数则称之为<em>方法</em>。</p>
<p>ECMAScript定义了一系列<em>内置对象</em>以描述ECMAScript实体。这些内置对象包括 <a href="https://www.ecma-international.org/ecma-262/8.0/index.html#global-object" target="_blank" rel="external">global object</a>; 对象是这门语言运行时语义化的基础，其中包括 <strong>Object</strong>，<strong>Function</strong>，<strong>Boolean</strong>，<strong>Symbol</strong>，和各种 <strong>Error</strong> 对象；<strong>Math</strong>，<strong>Number</strong> 和 <strong>Date</strong> 用以代表和操作数字；<strong>String</strong>，<strong>RegExp</strong> 用以操作文本；<strong>Array</strong> 以有序的方式存储值，另外还有<strong>九</strong>种类型的元素是特殊类型的数组；以键的方式存储的对象是 <strong>Map</strong> 和 <strong>Set</strong>；支持结构化数据形式的对象有：<strong>JSON</strong>，<strong>ArrayBuffer</strong>，<strong>ShareArrayBuffer</strong> 和 <strong>DateView</strong>；支持抽象的对象有 <em>generate function</em> 和 <strong>Promise</strong>；具有反射功能的对象有 <strong>Proxy</strong> 和 <strong>Reflext</strong>。</p>
<p>ECMAScript同时定义了一些<em>操作符(operators)</em>。其中包括一元操作符，multiplicative operators, additive operators, bitwise shift operators, relational operators, 等号操作符, binary bitwise operators, binary logical operators, assignment operators, and the comma operator.</p>
<p>大型的ECMAScript程序支持使用 <em>Module</em> 分离成一系列状态机和声明。每个模块可以清晰的使用别的模块或被别的模块使用。</p>
<p>ECMAScript的语法与Java的语法类似。ECMAScript语法是松散的为了创造出一种易用的脚本语言。例如，一个变量或一个特有属性不要描述其类型，(定义个函数也不需要在调用它之前显示声明)?.</p>
<h3 id="4-2-1-Objects"><a href="#4-2-1-Objects" class="headerlink" title="4.2.1 Objects"></a>4.2.1 Objects</h3><p>尽管ECMAScript包括类的声明，EMCAScript不像C++，Smalltalk 或 Java那样是基于类的语言。替代的有很多方式包括命令或者构造函数实例化对象然后初始化全部或者一部分特有属性。每一个构造函数都有一个特有属性 <strong>prototype</strong> 去实现<em>基于原型</em>的继承和共享特有属性。对象通过使用<strong>new</strong>表达式调用构造函数创建；例如<strong>new Date(2009,11)</strong> 创建事件对象。直接调用构造函数而非使用<strong>new</strong>得到的结果取决于构造函数本身。例如，<strong>Date()</strong> 使用字符串代替对象作为参数。</p>
<p>每一个被构造函数穿件出来的实例都有一个构造函数<em>prototype</em>的引用。此外，一个原型可能有它自己的原型引用，以此类推；这被称作<strong>原型链</strong>。当一个引用是一个对象的特有属性时，用属性名可以获取到在原型链中第一个含有这个名的对象。换言之，第一个对象检测是否含有这个名字的对象，如果有则命中了；如果没有这从原型链中寻找；</p>
<p><img src="/images/ecma/prototype-relationships.jpg" alt="Object/Prototype Relationships"></p>
<p>在以类为基础的面向对象语言中，实例持有状态，类持有方法，继承只是结构和行为上的。在ECMAScript中，对象持有状态和方法，同时结构，行为，状态都是继承的。</p>
<p>所有的对象并不直接持有那些来自于它们原型的特有属性和值。</p>
<p><strong>CF</strong> 是一个构造函数(同时也是一个对象)。五个对象是由<strong>new</strong>指令创建分别是<strong>cf1,cf2,cf3,cf4</strong> and <strong>cf5</strong>。每个对象都含有<strong>q1</strong> 和 <strong>q2</strong> 两个属性。虚线代表着原型关系；例如<strong>cf3</strong> 的原型是 <strong>CFp</strong>。构造函数 <strong>CF</strong>，含有两个属性 <strong>P1</strong> 和 <strong>P2</strong>,它们对 <strong>CFp，cf1,cf2,cf3,cf4</strong> 或 <strong>cf5</strong> 是不可见的。在 <strong>CFp</strong> 中的属性 <strong>CFP1</strong> 被 <strong>cf1，cf2，cf3，cf4</strong> 和 <strong>cf5</strong> 所共享，<strong>CFp</strong> 中的所有属性都在原型中不存在。注意 <strong>CF</strong> 和 <strong>CFp</strong> 之间没有隐式的原型链。</p>
<p>不像多数的基于类的对象语言，属性可以被动态的添加到对象上。构造函数不需要声明或指派所有或者部分属性的值。在上面的图中，可以通过指派一个新的值以共享给 <strong>cf1，cf2，cf3，cf4</strong> 和 <strong>cf5</strong>。</p>
<p>尽管 ECMAScript对象并非基于类，但为了方便经常定义和类类似的上层抽象构造函数，原型对象和方法。ECMAScript内置对象本身遵守类似类的模式。从ECMAScript2015开始，ECMAScript语言提供类语法可以让开发人员使用去构建抽象类。</p>
<h3 id="4-2-2-The-Strict-Variant-of-ECMAScript"><a href="#4-2-2-The-Strict-Variant-of-ECMAScript" class="headerlink" title="4.2.2 The Strict Variant of ECMAScript"></a>4.2.2 The Strict Variant of ECMAScript</h3><p>ECMAScript语言意识到可能存在一些用户可能希望限制某些功能的需求，他们可能对安全感兴趣，去避免一些易于出错的功能，去增强错误检测，或者有其他的原因。未来支持这种需求，ECMAScript定了一种限制多样性的语言。该语言的严格变体排除了常规ECMAScript语言的一些特定句法和语义特征，并修改了某些功能的详细语义。严格变体还指定了额外的错误条件，必须通过在不严格的语言形式指定为错误的情况下抛出错误异常来报告错误。</p>
<p>ECMAScript的严格变体通常被称为语言的严格模式。 ECMAScript的严格模式选择和使用严格模式语法和语义明确地在单个ECMAScript源文本单元的级别。因为在句法源文本单元的级别选择了严格模式，严格模式只会在这样的源文本单元中施加具有局部效果的限制。严格模式不会限制或修改必须在多个源文本单元上一致操作的ECMAScript语义的任何方面。完整的ECMAScript程序可能由严格模式和非严格模式ECMAScript源文本单元组成。在这种情况下，严格模式仅在实际执行在严格模式源文本单元中定义的代码时适用。</p>
<p>为了符合本规范，ECMAScript实现必须实现完全无限制的ECMAScript语言和本规范定义的ECMAScript语言的严格变体。此外，实现必须支持将无限制和严格模式源文本单元组合到单个复合程序中。</p>
<h2 id="4-3-Terms-and-Definitions"><a href="#4-3-Terms-and-Definitions" class="headerlink" title="4.3 Terms and Definitions"></a>4.3 Terms and Definitions</h2><p>为了本文档的目的，适用以下术语和定义。</p>
<h3 id="4-3-1-Type"><a href="#4-3-1-Type" class="headerlink" title="4.3.1 Type"></a>4.3.1 Type</h3><p>本规范第6条定义的一组数据值</p>
<h3 id="4-3-2-primitive-value"><a href="#4-3-2-primitive-value" class="headerlink" title="4.3.2 primitive value"></a>4.3.2 primitive value</h3><p>Undefined, Null, Boolean, Number, Symbol 或者 String中的一种正如第6条定义的。<br>NOTE: 原始值是直接在语言实现的最低级别表示的基准</p>
<h3 id="4-3-3-object"><a href="#4-3-3-object" class="headerlink" title="4.3.3 object"></a>4.3.3 object</h3><p>Object类型<br>NOTE： 一个对象是一组属性的集合并且含有一个原型对象。原型对象可能是Null</p>
<h3 id="4-3-4-constructor"><a href="#4-3-4-constructor" class="headerlink" title="4.3.4 constructor"></a>4.3.4 constructor</h3><p>创建和实例化对象的函数对象<br>NOTE： 构造函数的 <strong>prototype</strong> 属性是一个用来实现继承和属性共享的原型对象</p>
<h3 id="4-3-5-prototype"><a href="#4-3-5-prototype" class="headerlink" title="4.3.5 prototype"></a>4.3.5 prototype</h3><p>给其他对象提供共享属性的对象<br>NOTE： 当构造函数创建一个对象时，为了解析属性引用，该对象隐式引用构造函数的prototype属性。构造函数的prototype属性可以由程序表达式constructor.prototype引用，并且添加到对象的原型中的属性通过继承由共享原型的所有对象进行共享。或者，可以使用Object.create内置函数通过明确指定的原型创建一个新对象。</p>
<h3 id="4-3-6-ordinary-object"><a href="#4-3-6-ordinary-object" class="headerlink" title="4.3.6 ordinary object"></a>4.3.6 ordinary object</h3><p>对象具有所有对象必须支持的基本内部方法的默认行为</p>
<h3 id="4-3-7-exotic-object"><a href="#4-3-7-exotic-object" class="headerlink" title="4.3.7 exotic object"></a>4.3.7 exotic object</h3><p>对象不具有一个或多个必要内部方法的默认行为<br>NOTE： 任何对象必然是ordinary或exotic对象中的一种</p>
<h3 id="4-3-8-standard-object"><a href="#4-3-8-standard-object" class="headerlink" title="4.3.8 standard object"></a>4.3.8 standard object</h3><p>其语义由本规范定义的对象</p>
<h3 id="4-3-9-build-in-object"><a href="#4-3-9-build-in-object" class="headerlink" title="4.3.9 build-in object"></a>4.3.9 build-in object</h3><p>对象由ECMAScript描述和支持<br>NOTE： 标准的内置对象在本文档中定义。一个ECMASciprt实现者可能描述和提供额外的内置对象。一个内置构造函数也是一个内置对象更是一个构造函数</p>
<h3 id="4-3-10-undefined-value"><a href="#4-3-10-undefined-value" class="headerlink" title="4.3.10 undefined value"></a>4.3.10 undefined value</h3><p>原始值被用于定义没有赋值的变量</p>
<h3 id="4-3-11-Undefined-type"><a href="#4-3-11-Undefined-type" class="headerlink" title="4.3.11 Undefined type"></a>4.3.11 Undefined type</h3><p><strong>undefined</strong> 的类型</p>
<h3 id="4-3-12-null-value"><a href="#4-3-12-null-value" class="headerlink" title="4.3.12 null value"></a>4.3.12 null value</h3><p>原始值被用于代表没有任何值</p>
<h3 id="4-3-13-Null-type"><a href="#4-3-13-Null-type" class="headerlink" title="4.3.13 Null type"></a>4.3.13 Null type</h3><p><strong>null</strong> 的类型</p>
<h3 id="4-3-14-Boolean-value"><a href="#4-3-14-Boolean-value" class="headerlink" title="4.3.14 Boolean value"></a>4.3.14 Boolean value</h3><p>布尔类型的成员<br>NOTE： 布尔值只有两个：<strong>true</strong> 和 <strong>false</strong></p>
<h3 id="4-3-15-Boolean-type"><a href="#4-3-15-Boolean-type" class="headerlink" title="4.3.15 Boolean type"></a>4.3.15 Boolean type</h3><p><strong>true</strong> 和 <strong>false</strong> 的类型</p>
<h3 id="4-3-16-Boolean-object"><a href="#4-3-16-Boolean-object" class="headerlink" title="4.3.16 Boolean object"></a>4.3.16 Boolean object</h3><p>对象类型并由内置构造函数 <strong>Boolean</strong> 实例化<br>NOTE： 一个布尔对象由使用<strong>new</strong>指令调用<strong>Boolean</strong>构造函数创建，支持布尔值为参数。返回一个内置布尔值的对象。一个布尔对象可以被转化成布尔值。</p>
<h3 id="4-3-17-String-value"><a href="#4-3-17-String-value" class="headerlink" title="4.3.17 String value"></a>4.3.17 String value</h3><p>原始值有限有序的一组0或多个16-bit无符号数字的值<br>NOTE: 一个字符串值是一个字符类型。序列中的每一个数字位通常代表了一个16bit单元的utf-16文本。然而，ECMAScript不对值进行任何限制或要求，除了它们必须是16位无符号整数</p>
<h3 id="4-3-18-String-type"><a href="#4-3-18-String-type" class="headerlink" title="4.3.18 String type"></a>4.3.18 String type</h3><p>字符串值得类型</p>
<h3 id="4-3-19-String-object"><a href="#4-3-19-String-object" class="headerlink" title="4.3.19 String object"></a>4.3.19 String object</h3><p>对象类型的内置构造函数 <strong>String</strong> 的实例<br>NOTE： 一个字符串对象由使用 <strong>new</strong> 命令创建，接收字符串值作为参数。返回一个内置字符串值得对象。一个字符串对象可以被转化成字符串值通过调用 <strong>String</strong> 构造函数(<a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-string-constructor-string-value" target="_blank" rel="external">21.1.1</a>)</p>
<h3 id="4-3-20-Number-value"><a href="#4-3-20-Number-value" class="headerlink" title="4.3.20 Number value"></a>4.3.20 Number value</h3><p>原始值对应于双精度64位二进制格式IEEE 754-2008值<br>NOTE： 一个数字类型为数值类型直接代表数字</p>
<h3 id="4-3-21-Number-type"><a href="#4-3-21-Number-type" class="headerlink" title="4.3.21 Number type"></a>4.3.21 Number type</h3><p>包括所有可能是数字值得类型包括“Not-a-Number”(NaN)，正无穷和负无穷</p>
<h3 id="4-3-22-Number-object"><a href="#4-3-22-Number-object" class="headerlink" title="4.3.22 Number object"></a>4.3.22 Number object</h3><p>对象类型的由内置构造函数 <strong>Number</strong> 实例化而来<br>NOTE： 一个数值对象由使用 <strong>new</strong> 命令调用 <strong>Number</strong> 构造函数创建，支持使用数字值作为参数。返回一个内置数值的对象。一个数值对象可被转化成数值通过调用 <strong>Number</strong> 构造函数作为一个函数使用(<a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-number-constructor-number-value" target="_blank" rel="external">20.1.1</a>)</p>
<h3 id="4-3-23-Infinity"><a href="#4-3-23-Infinity" class="headerlink" title="4.3.23 Infinity"></a>4.3.23 Infinity</h3><p>数值类型代表无穷的数值</p>
<h3 id="4-3-24-NaN"><a href="#4-3-24-NaN" class="headerlink" title="4.3.24 NaN"></a>4.3.24 NaN</h3><p>数值符合IEEE 754-2008 “Not-a-Number”的值</p>
<h3 id="4-3-25-Symbol-value"><a href="#4-3-25-Symbol-value" class="headerlink" title="4.3.25 Symbol value"></a>4.3.25 Symbol value</h3><p>原始值代表唯一的，非字符串的对象属性的键</p>
<h3 id="4-3-26-Symbol-type"><a href="#4-3-26-Symbol-type" class="headerlink" title="4.3.26 Symbol type"></a>4.3.26 Symbol type</h3><p>symbol值得类型</p>
<h3 id="4-3-27-Symbol-object"><a href="#4-3-27-Symbol-object" class="headerlink" title="4.3.27 Symbol object"></a>4.3.27 Symbol object</h3><p>对象类型由标准内置<strong>Symbol</strong>构造函数创建</p>
<h3 id="4-3-28-function"><a href="#4-3-28-function" class="headerlink" title="4.3.28 function"></a>4.3.28 function</h3><p>对象类型用于创建子程序<br>NOTE： 除自身属性外，一个函数包含可执行的代码和状态去描述被调用后的行为。一个函数的代码可能不是用ECMAScript。</p>
<h3 id="4-3-29-build-in-function"><a href="#4-3-29-build-in-function" class="headerlink" title="4.3.29 build-in function"></a>4.3.29 build-in function</h3><p>内置对象是一个函数<br>NOTE: 例如 <strong><em>parseInt</em></strong> 和 <strong>Math。exp</strong>。一个实现者可能提供独立实现的内置函数，而不是本文档的范畴</p>
<h3 id="4-3-30-property"><a href="#4-3-30-property" class="headerlink" title="4.3.30 property"></a>4.3.30 property</h3><p>将一个关键字（一个String值或一个Symbol值）和一个值相关联的对象的一部分<br>NOTE: 根据属性的形式，该值可以直接表示为数据值（原始值，对象或函数对象）或由一对访问器函数间接表示。</p>
<h3 id="4-3-31-method"><a href="#4-3-31-method" class="headerlink" title="4.3.31 method"></a>4.3.31 method</h3><p>以属性方式出现在对象中的函数<br>NOTE: 当一个函数被当作一个对象的方法被调用时，这个对象将被以 <strong>this</strong> 的方式传递给函数。</p>
<h3 id="4-3-21-build-in-method"><a href="#4-3-21-build-in-method" class="headerlink" title="4.3.21 build-in method"></a>4.3.21 build-in method</h3><p>方法就是内置函数<br>NOTE： 标准的内置方法在本文档中被定义，一个ECMAScript实现者可能描述和提供额外的内置方法</p>
<h3 id="4-3-33-attribute"><a href="#4-3-33-attribute" class="headerlink" title="4.3.33 attribute"></a>4.3.33 attribute</h3><p>定义属性某些特性的内部值</p>
<h3 id="4-3-34-own-property"><a href="#4-3-34-own-property" class="headerlink" title="4.3.34 own property"></a>4.3.34 own property</h3><p>由其对象直接包含的属性</p>
<h3 id="4-3-35-inherited-property"><a href="#4-3-35-inherited-property" class="headerlink" title="4.3.35 inherited property"></a>4.3.35 inherited property</h3><p>属性不属于自己的属性，但是对象的原型的属性（自己的或继承的）</p>
<h2 id="4-4-Organization-of-This-Specification"><a href="#4-4-Organization-of-This-Specification" class="headerlink" title="4.4 Organization of This Specification"></a>4.4 Organization of This Specification</h2><p>本规范的其余部分组织如下：</p>
<p>条款5定义了整个规范中使用的符号约定。</p>
<p>第6-9条定义ECMAScript程序运行的执行环境。</p>
<p>第10-16条定义了实际的ECMAScript编程语言，包括其语法编码和所有语言特征的执行语义。</p>
<p>第17-26条定义了ECMAScript标准库。它们包括ECMAScript程序执行时可以使用的所有标准对象的定义。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qudi15.github.io/blog/2017/08/21/ecma-262-4/" data-id="cj6ox2ws10003f3g3f5eivk4s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2017/08/21/VueJs-source/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          VueJs source analysis
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/08/">August 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2017/08/23/ecma-262-6/">ECMA-262 Clause 6</a>
          </li>
        
          <li>
            <a href="/blog/2017/08/23/ecma-262-5/">ECMA-262 Clause 5</a>
          </li>
        
          <li>
            <a href="/blog/2017/08/21/VueJs-source/">VueJs source analysis</a>
          </li>
        
          <li>
            <a href="/blog/2017/08/21/ecma-262-4/">ECMA-262 Clause 4</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 曲迪(Eddy)<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

  </div>
</body>
</html>